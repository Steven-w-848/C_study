#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>

//int main()
//{
	////////////////操作符详解///////////////////


/////////算数操作符////////
	//  '/'
	//int a = 6 / 5;//答案为1
	//float a = 6 / 5; //答案为1
	//float a = 6.0 / 5; //答案为1.2
	//使用'/'时，若要使得答案为浮点数，数据类型改为浮点型并不会改变结果，需要将计算中至少一个数写为浮点形式


	//'%'
	//取模符号两边必须一致为整数


//////////移位操作符///////////
	//'<<'左移位操作符
	//int a = 2;
	//int b = a << 1;//答案为4
	//使用左移位操作符时，会将原数据的32位二进制数向左移位，空缺出的空位用0补位，得到新的32位二进制数

	//'>>'右移位操作符
	//右移位操作符分为   1.算数右移    2.逻辑右移
	//算数右移： 右边丢弃，左边补原符号位
	//逻辑右移： 右边丢弃，左边补0
	//当前的右移操作符使用的是算数右移

	//移位操作符不会改变变量原来的值

	//负整数的二进制表示形式分为三种
	//原码：直接根据数值写出的二进制序列就是原码
	//反码：原码的符号位不变，其它按按位取反就是反码
	//补码：反码+1，就是补码

    //正数的原码反码补码都一样！

	//例子：-1
	//原码：10000000000000000000000000000001   //第一位为符号位，0为正，1为负
	//反码：11111111111111111111111111111110
	//补码：11111111111111111111111111111111

    //内存中存储以及运算时使用的是补码

///////////位操作符////////////

	//////'&' '|' '^'//////

	//int a = 3;
	//int b = 5;
	//a: 00000000000000000000000000000011
	//b: 00000000000000000000000000000101


	// & - 按（二进制）位与
	//int c = a & b;
	//printf("%d", c);
	//按位与&逻辑：逐位比较两个数的二进制序列，同真为真（只有两个位上都是1时结果才为1）

	// | - 按（二进制）位或
	//int c = a | b;
	//printf("%d", c);
	//按位或|逻辑：逐位比较两个数的二进制序列，有真为真（只要两个位上有一个1结果就为1）

	// ^ - 按（二进制）位异或
	//int c = a | b;
	//printf("%d", c);
	//按位异或^逻辑：逐位比较两个数的二进制序列，相同为0，相异为1



	//不定义第三个变量来交换两个变量的值
	//int a = 3;
	//int b = 5;
	//printf("a = %d,b = %d\n", a, b);
	//a = a + b;
	//b = a - b;
	//a = a - b;
	//printf("a = %d,b = %d\n", a, b);
	//此算法若数字太大会溢出

	//使用异或来实现
	//int a = 3;
	//int b = 5;
	//printf("a = %d,b = %d\n", a, b);
	//a = a ^ b;
	//b = a ^ b;
	//a = a ^ b;
	//printf("a = %d,b = %d\n", a, b);
	//按位异或有个特性：若c = a^b, 则a = b^c 且 b = a^c


	//////赋值操作符//////
	// '='给变量自定义赋值
	//int a = 1, b = 2, c = 3;
	//a = b = c + 1;
	//上为连续赋值，运行时从右向左，先执行b=c+1，再执行a=b


	//////单目操作符//////

	// '!' - 逻辑取反
    //int flag = 0;
	//if (flag)
	//	printf("假");
	//if (!flag)
	//	printf("真");


    // '~' - 按位取反
        //int a = -1;
		//10000000000000000000000000000001  原码
		//11111111111111111111111111111110  反码
		//11111111111111111111111111111111  补码
		//从原码到补码的过程叫做按位取反
		//在内存中的存储形式为补码

    // '++' 和  '--' 
        //int a = 10;
        //int b = a++; //后置++，先使用，再++
        //int c = ++a; //前置 ++，先++，再使用


    // '*' 和 '&'
        //int a = 10;
		//printf("%p\n", &a);  // & - 取地址操作符
		//int* pa = &a; //pa是用来存放地址的 - pa就是一个指针变量
		//*pa = 20; //* - 解引用操作符 - 间接访问操作符
		//printf("%d\n", a); //20


    // '(类型)' - 强制类型转换
		//int a = (int)3.14;


//////关系操作符//////
    // >  >=  <  <=  !=  ==


//////逻辑操作符//////
// '&&' - 逻辑与      '||' - 逻辑或
//例题
        //int i = 0;
		//int a = 0;
		//int b = 2;
		//int c = 3;
		//int d = 4;
		//i = a++ && ++b && d++;
		//printf("a=%d\nb=%d\nc=%d\nd=%d\n", a, b, c, d); //答案为1,2,3,4
        //在计算第一个'a++ '部分的时候，计算结果为0；由于这几个部分用 '&&' - 和 连接,有零则答案必为零，
		//故后面的部分便不再计算


//////条件操作符(三目操作符)//////
      //常规写法
		//int a = 3;
		//int b = 0;
		//if (a > 5)
		//	b = 1;
		//else
		//	b = -1;
      
      //使用三目操作符
	    //int a = 3;
		//int b = 0;
		//b = (a > 5 ? 1 : -1);


//////逗号表达式//////
		//int a = 0;
		//int b = 3; 
		//int c = 5;
		//int d = (c = 0, a = c + 3, b = a - 2, c += 5);
		//printf("%d", d);  //答案为5
		//逗号表达式 - 从左向右依次计算，但是整个表达式的结果是最后一个表达式的结果


//////下标引用操作符、函数调用操作符、结构成员操作符//////

      //'[]' - 下标引用操作符
		//int arr[] = { 1,2,3,4,5 };
		//printf("%d", arr[2]);  //'[]' - 下标引用
        //上面'[]'的操作数有两个：arr, 2

      //'()'函数调用操作符
      //Add（a, b）;  //操作数： Add, a, b
        
//		return 0;
//}


//////'.' - 结构成员操作符//////
//struct Book
//{
//	char name[20];
//	char id[20];
//	int price;
//};
//
//int main()
//{
//	struct Book b = { "C语言","C20230319",55 };
//	struct Book* pb = &b;
//	printf("书名：%s\n", b.name);      //结构体变量名.成员名
//	printf("书号：%s\n", (*pb).id);    //结构体指针
//	printf("价格：%d元\n", pb->price); //结构体指针->成员名
//}




     //////整形提升//////

//int main()
//{
//	char a = 3; //char类型占一个字节  //00000000000000000000000000000011 截后 00000011
//	char b = 127;                     //00000000000000000000000001111111 截后 01111111
//	char c = a + b;
//	//c = a + b = 00000000000000000000000010000010  截后 10000010
//	//11111111111111111111111110000010 - 补码 （整形提升）
//	//11111111111111111111111110000001 - 反码
//	//10000000000000000000000001111110 - 原码
//	// -126
//	printf("%d", c);
//	//计算机运行时运算器的操作数的字节长度一般是int的长度
//	//这里计算时会发现a和b都是char类型的，都没有达到一个int的大小
//	//这里就会发生整形提升
//	//整形提升是按照变量的数据类型的符号位来提升的，缺失的高位用符号位补充
//	//无符号整形提升，高位补0
//
//	return 0;
//}



    //////算数转换//////

//如果某个操作符的各个操作数属于不同类型，那么除非其中一个操作数转化为另一个操作数的类型，否则操作就无法进行
//一般算数转换会将精度较低的变量类型转换为精度更高的变量类型



    //////计算的优先级和结合性//////
//int main()
//{
//	int a = 3;
//	int b = 5;
//	int c = a + b * 7;  //符号不同，优先级决定计算顺序
//	int d = a + b + 7;  //符号相同，结合性决定计算顺序
//	return 0;
//}



